{"version":3,"sources":["../src/index.js"],"names":["createFindDebugLevel","specialRegexpChars","createTestFunctionFromRegexpString","value","endsWith","Error","regexp","RegExp","slice","string","test","createTestFunctionFromValue","startsWith","debugValue","wilcard","debugValues","skips","Array","isArray","trim","push","split","forEach","substr","length","ALL","minLevel","key","some","skip"],"mappings":";;;;;kBAqBwBA,oB;;AArBxB;;;;;;AAEA,MAAMC,qBAAqB,mBAA3B;;AAIA,MAAMC,qCAAsCC,KAAD,IAAW;AACpD,MAAI,CAACA,MAAMC,QAAN,CAAe,GAAf,CAAL,EAA0B,MAAM,IAAIC,KAAJ,CAAU,4BAAV,CAAN;AAC1B,QAAMC,SAAS,IAAIC,MAAJ,CAAWJ,MAAMK,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,CAAX,CAAf;AACA,SAAOC,UAAUH,OAAOI,IAAP,CAAYD,MAAZ,CAAjB;AACD,CAJD;;AAMA,MAAME,8BAA+BR,KAAD,IAAW;AAC7C,MAAIA,MAAMC,QAAN,CAAe,IAAf,CAAJ,EAA0B;AACxBD,YAAQA,MAAMK,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,CAAR;AACA,WAAOC,UAAUA,OAAOG,UAAP,CAAkBT,KAAlB,CAAjB;AACD;;AAED,SAAOM,UAAUA,WAAWN,KAA5B;AACD,CAPD;;AASe,SAASH,oBAAT,CAA8Ba,UAA9B,EAA2D;AACxEA,eAAcA,cAAc,EAA5B;;AAEA,MAAIC,UAAU,KAAd;AACA,QAAMC,gBAAN;AACA,QAAMC,UAAN;;AAEA,MAAI,CAACC,MAAMC,OAAN,CAAcL,UAAd,CAAL,EAAgC;AAC9BA,iBAAaA,WAAWM,IAAX,EAAb;;AAEA,QAAIN,WAAWD,UAAX,CAAsB,GAAtB,CAAJ,EAAgC;AAC9BG,kBAAYK,IAAZ,CAAiBlB,mCAAmCW,UAAnC,CAAjB;AACAA,mBAAa,IAAb;AACD,KAHD,MAGO;AACLA,mBAAaA,WAAWQ,KAAX,CAAiB,QAAjB,CAAb;AACD;AACF;;AAED,MAAIR,UAAJ,EAAgB;AACdA,eAAWS,OAAX,CAAmBnB,SAAS;AAC1B,UAAIF,mBAAmBS,IAAnB,CAAwBP,KAAxB,CAAJ,EAAoC;AAClC,cAAM,IAAIE,KAAJ,CAAW,yBAAwBF,KAAM,4BAAzC,CAAN;AACD;;AAED,UAAI,CAACA,KAAL,EAAY;;AAEZ,UAAIA,UAAU,GAAd,EAAmB;AACjBW,kBAAU,IAAV;AACA;AACD;;AAED,UAAIX,MAAMS,UAAN,CAAiB,GAAjB,CAAJ,EAA2B;AACzBI,cAAMI,IAAN,CAAWT,4BAA4BR,MAAMoB,MAAN,CAAa,CAAb,CAA5B,CAAX;AACD,OAFD,MAEO,IAAI,CAACT,OAAL,EAAc;AACnBC,oBAAYK,IAAZ,CAAiBT,4BAA4BR,KAA5B,CAAjB;AACD;AACF,KAjBD;AAkBD;;AAED,MAAIW,OAAJ,EAAa;AACX,QAAIE,MAAMQ,MAAN,KAAiB,CAArB,EAAwB;AACtB,aAAO,MAAc,4BAAOC,GAA5B;AACD,KAFD,MAEO;AACL,aAAO,CAACC,QAAD,EAAWC,GAAX,KACLX,MAAMY,IAAN,CAAWC,QAAQA,KAAKF,GAAL,CAAnB,IAAgCD,QAAhC,GAA2C,4BAAOD,GADpD;AAGD;AACF;;AAED,MAAIV,YAAYS,MAAZ,KAAuB,CAA3B,EAA8B;AAC5B,WAAQE,QAAD,IAAsBA,QAA7B;AACD;;AAED,SAAO,CAACA,QAAD,EAAWC,GAAX,KAAmB;AACxB,QAAID,aAAa,4BAAOD,GAApB,IAA2B,CAACE,GAAhC,EAAqC;AACnC,aAAOD,QAAP;AACD;;AAED,QAAIX,YAAYa,IAAZ,CAAiBf,cAAcA,WAAWc,GAAX,CAA/B,CAAJ,EAAqD;AACnD,aAAOX,MAAMY,IAAN,CAAWC,QAAQA,KAAKF,GAAL,CAAnB,IAAgCD,QAAhC,GAA2C,4BAAOD,GAAzD;AACD;;AAED,WAAOC,QAAP;AACD,GAVD;AAWD","file":"index.js","sourcesContent":["import levels from 'nightingale-levels';\n\nconst specialRegexpChars = /[\\\\^$+?.()|[\\]{}]/;\n\ntype DebugValueType = string | RegExp | Array<string | RegExp>;\n\nconst createTestFunctionFromRegexpString = (value) => {\n  if (!value.endsWith('/')) throw new Error('Invalid RegExp DEBUG value');\n  const regexp = new RegExp(value.slice(1, -1));\n  return string => regexp.test(string);\n};\n\nconst createTestFunctionFromValue = (value) => {\n  if (value.endsWith(':*')) {\n    value = value.slice(0, -2);\n    return string => string.startsWith(value);\n  }\n\n  return string => string === value;\n};\n\nexport default function createFindDebugLevel(debugValue: ?DebugValueType) {\n  debugValue = (debugValue || '');\n\n  let wilcard = false;\n  const debugValues = [];\n  const skips = [];\n\n  if (!Array.isArray(debugValue)) {\n    debugValue = debugValue.trim();\n\n    if (debugValue.startsWith('/')) {\n      debugValues.push(createTestFunctionFromRegexpString(debugValue));\n      debugValue = null;\n    } else {\n      debugValue = debugValue.split(/[\\s,]+/);\n    }\n  }\n\n  if (debugValue) {\n    debugValue.forEach(value => {\n      if (specialRegexpChars.test(value)) {\n        throw new Error(`Invalid debug value: \"${value}\" (contains special chars)`);\n      }\n\n      if (!value) return;\n\n      if (value === '*') {\n        wilcard = true;\n        return;\n      }\n\n      if (value.startsWith('-')) {\n        skips.push(createTestFunctionFromValue(value.substr(1)));\n      } else if (!wilcard) {\n        debugValues.push(createTestFunctionFromValue(value));\n      }\n    });\n  }\n\n  if (wilcard) {\n    if (skips.length === 0) {\n      return (minLevel) => levels.ALL;\n    } else {\n      return (minLevel, key) => (\n        skips.some(skip => skip(key)) ? minLevel : levels.ALL\n      );\n    }\n  }\n\n  if (debugValues.length === 0) {\n    return (minLevel: number) => minLevel;\n  }\n\n  return (minLevel, key) => {\n    if (minLevel === levels.ALL || !key) {\n      return minLevel;\n    }\n\n    if (debugValues.some(debugValue => debugValue(key))) {\n      return skips.some(skip => skip(key)) ? minLevel : levels.ALL;\n    }\n\n    return minLevel;\n  };\n}\n"]}